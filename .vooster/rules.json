{
  "rules": [
    {
      "type": "prd",
      "content": "# 노플 자동 타이머 PRD\n\n## 1. 개요\nLoL 플레이 중 음성 명령(\"탑 노플\", \"미드 노플\" 등)을 한국어로 인식하여 라인별 5분 타이머를 자동으로 시작‧관리해 주는 PC 브라우저 전용 웹앱. 사용자는 화면 전환이나 수동 입력 없이 자신의 노플 정보를 빠르게 확인하여 플레이 효율을 높일 수 있다.\n\n## 2. 목표 및 성공 지표\n| 목표 | 성공 지표 |\n|------|-----------|\n|사용자 집중도 향상| • 음성 명령 반응 시간 ≤ 1초  \n• 게임 세션당 화면 전환 횟수 0회 유지|\n|정확한 노플 타이머 제공| • 음성 인식 정확도 ≥ 90%  \n• 잘못 시작된 타이머 비율 ≤ 5%|\n|제품 채택| • 출시 1개월 내 DAU 1,000명  \n• 후원 전환율 2%|\n\n## 3. 대상 사용자\n• 친구들과 5인 파티로 LoL 일반전·커스텀 게임을 즐기는 PC 플레이어  \n• 한국어 음성 채팅 환경(디스코드 등)을 사용하는 사용자  \n• 노플 시간을 직접 기록하느라 집중력이 분산되는 유저\n\n## 4. 사용자 목표\n• 노플 시간을 자동으로 기록해 전투와 전략 판단에 집중  \n• 게임 화면을 전환하지 않고 간편하게 노플 정보를 확인  \n• 불필요한 팀 커뮤니케이션 부담 감소\n\n## 5. 주요 Pain Point\n1. 음성이나 채팅으로 노플 정보를 직접 공유하느라 지연 발생  \n2. 타이머 기록이 누락돼 전략적 손실 발생\n\n## 6. 기능 범위\n### 6.1 MVP 포함 기능\n1. 한국어 음성 명령(\"탑/정글/미드/원딜/서폿 노플\") 감지  \n2. 감지 즉시 해당 라인 5분 타이머 시작  \n3. 라인별 실시간 타이머 UI(React)  \n4. 타이머 종료 1분 전 음성 알림 + UI 강조  \n5. 수동 클릭 또는 핫키(F1~F5)로 타이머 시작·리셋  \n6. 게임 화면 위 작은 HUD(오버레이) 표시\n\n### 6.2 추후(Backlog) 기능\n• 다국어(영어) 지원  \n• 라인별 알림 음성/볼륨 커스터마이즈  \n• 타이머 기록 공유·저장 기능  \n• 모바일 웹 지원\n\n### 6.3 제외(Non-Goals)\n• 서버 측 매칭 데이터 연동  \n• AI 전략 추천  \n• 결제형 프리미엄 구독(초기 단계 제외)\n\n## 7. 사용자 플로우\n1. 사용자가 웹사이트 접속 → \"Start\" 버튼 클릭  \n2. 브라우저 마이크 권한 요청 허용  \n3. 대기 화면 + HUD 활성화  \n4. 사용자가 \"탑 노플\" 발화 → 1초 내 타이머 시작  \n5. HUD 및 메인 UI에서 타이머 진행 상황 표시  \n6. 1분 전 음성 \"탑 플래시 1분 전\" 알림  \n7. 0초 시각·음성 알림 후 타이머 색상 강조 & 종료  \n8. 필요 시 사용자가 클릭/핫키로 재설정\n\n## 8. 기술 요구 사항\n• Frontend: React + Vite + Tailwind  \n• 음성 인식: WebAssembly 기반 Whisper Live(또는 바닐라 Web Speech API fallback)  \n• 지연 허용 범위: 1초 이하  \n• 오프라인 동작은 고려하지 않음  \n• 데이터 영속화 없음(세션 메모리)\n\n## 9. 성능/품질 기준\n• 음성 인식 정확도 ≥ 90% (한국어)  \n• 반응 속도 ≤ 1초  \n• HUD CPU 점유율 ≤ 3% (중급 사양 PC 기준)\n\n## 10. 리스크 및 대응\n| 리스크 | 심각도 | 대응 |\n|---------|--------|------|\n|브라우저별 마이크 권한 차이|중|허용 가이드 팝업 & FAQ 제공|\n|Whisper WASM 모델 용량(수 MB)|중|네트워크 지연 시 Web Speech API 예비 경로|\n|게임 전체화면 시 HUD 오버레이 불가|상|Borderless Window 모드 안내 & 데스크톱 캡처 오버레이 실험|\n\n## 11. 타임라인(예상)\n| 주차 | 마일스톤 |\n|------|-----------|\n|1주차|Whisper WASM POC, 인식 정확도 테스트|\n|2주차|React UI, 라인별 타이머 컴포넌트 구현|\n|3주차|HUD 오버레이, 1분 전 알림 추가|\n|4주차|핫키·수동 컨트롤, QA, 버그픽스|\n|5주차|MVP 공개, 피드백 수집|\n\n## 12. 비용 & 수익화\n• 비용: 도메인, 호스팅(Vercel Free Tier), Whisper 모델 CDN 전송량  \n• 수익화: 선택적 후원 버튼(Patreon/BuyMeACoffee) UI 노출  \n• ROI 목표: 서버비 100% 상쇄\n\n## 13. 승인\n제품 오너: [캡틴]  \n작성일: 2025-09-10",
      "writedAt": "2025-09-10T05:39:32.231Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **Project Overview**: 본 프로젝트는 LoL 플레이어들이 한국어 음성 명령을 통해 라인별 노플 타이머를 자동 관리할 수 있는 PC 브라우저 웹앱을 개발하는 것을 목표로 한다. 주요 기능은 음성 인식, 타이머 관리, 실시간 UI 업데이트, 알림 제공이며, 이를 통해 사용자는 게임에 더욱 집중하고 전략적 판단을 효율적으로 수행할 수 있다.\n- **Core Technology Stack**: React, Vite, TailwindCSS, TypeScript, Whisper WASM을 기반으로 구축하며, 필요에 따라 Cloudflare Pages 및 Cloudflare Workers를 활용한다.\n- **Key Technical Objectives**: 1초 이내의 음성 명령 반응 속도, 90% 이상의 음성 인식 정확도, 낮은 CPU 점유율을 목표로 한다.\n- **Critical Technical Assumptions**: 사용자는 Chrome, Edge 등 최신 브라우저를 사용하며, 안정적인 인터넷 연결을 가정한다. 오프라인 동작은 지원하지 않는다.\n\n## 2. Tech Stack\n\n| Category          | Technology / Library        | Reasoning (Why it's chosen for this project) |\n| ----------------- | --------------------------- | -------------------------------------------- |\n| Frontend Framework | React                       | 컴포넌트 기반 UI 개발에 용이하며, 풍부한 생태계와 재사용성 높은 컴포넌트 구축에 적합하다. |\n| Build Tool        | Vite                        | 빠른 개발 서버 시작 및 빌드 속도를 제공하여 개발 생산성을 향상시킨다. |\n| Styling           | TailwindCSS                 | 유틸리티 기반 CSS 프레임워크로, 빠른 UI 스타일링 및 일관성 유지에 효과적이다. |\n| Language          | TypeScript                  | 정적 타입 검사를 통해 코드 안정성을 높이고, 유지보수성을 향상시킨다. |\n| Speech Recognition| Whisper WASM               | 로컬에서 실행되는 WebAssembly 기반 음성 인식 라이브러리로, 빠른 응답 속도와 개인 정보 보호에 유리하다. Web Speech API를 fallback으로 사용하여 안정성을 확보한다. |\n| Deployment        | Cloudflare Pages            | 정적 웹사이트 호스팅에 최적화되어 있으며, 글로벌 CDN을 통해 빠른 콘텐츠 전송이 가능하다. |\n| Backend (Optional)| Cloudflare Workers          | 서버리스 환경에서 간단한 API 및 백엔드 로직을 구현할 수 있으며, 필요에 따라 추가 기능을 확장할 수 있다. |\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n- **Frontend (React UI)**:\n    - 사용자 인터페이스 (HUD, 메인 UI)\n    - 음성 입력 처리 및 Whisper WASM 연동\n    - 타이머 상태 관리 및 업데이트\n    - 알림 및 시각 효과 제어\n- **Speech Recognition Module (Whisper WASM)**:\n    - 한국어 음성 인식\n    - 텍스트 변환\n    - 명령 추출\n- **Timer Management Module**:\n    - 라인별 타이머 생성 및 관리\n    - 타이머 상태 업데이트 (시작, 종료, 재설정)\n    - 알림 트리거\n- **Cloudflare Pages (Hosting)**:\n    - 정적 자산 (HTML, CSS, JavaScript) 호스팅\n    - CDN을 통한 빠른 콘텐츠 전송\n- **Cloudflare Workers (Optional)**:\n    - (선택 사항) 간단한 API 엔드포인트 제공\n    - (선택 사항) 데이터 처리 및 로직 실행\n\n### Top-Level Component Interaction Diagram\n\n```mermaid\ngraph TD\n    A[User] --> B[Frontend (React UI)]\n    B --> C[Speech Recognition Module (Whisper WASM)]\n    C --> B\n    B --> D[Timer Management Module]\n    D --> B\n    B -- HTTP/HTTPS --> E[Cloudflare Pages]\n    E --> F[Cloudflare Workers (Optional)]\n```\n\n- 사용자는 웹 브라우저를 통해 Frontend (React UI)와 상호 작용한다.\n- Frontend는 사용자의 음성 입력을 Speech Recognition Module (Whisper WASM)로 전달하여 텍스트로 변환한다.\n- 변환된 텍스트는 명령으로 해석되어 Timer Management Module에 전달되고, 타이머가 시작, 종료, 재설정된다.\n- Timer Management Module은 타이머 상태를 Frontend에 업데이트하고, Frontend는 사용자에게 시각적, 청각적 알림을 제공한다.\n- Frontend는 Cloudflare Pages를 통해 호스팅되며, Cloudflare Workers를 통해 추가적인 백엔드 로직을 처리할 수 있다.\n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**\n- **Domain Separation**: 음성 인식, 타이머 관리, UI 컴포넌트 등 각 기능 도메인별로 코드를 분리한다.\n- **Layer-Based Architecture**: 프레젠테이션 레이어 (UI 컴포넌트), 비즈니스 로직 레이어 (타이머 관리), 데이터 레이어 (Whisper WASM 연동)로 분리한다.\n- **Feature-Based Modules**: 각 라인별 타이머 기능을 모듈로 구성하여 독립적으로 관리한다.\n- **Shared Components**: 공통으로 사용되는 UI 컴포넌트 (버튼, 타이머 표시 등) 및 유틸리티 함수를 공유 모듈에 정의한다.\n\n**Universal File & Folder Structure**\n```\n/\n├── src/\n│   ├── components/          # 재사용 가능한 UI 컴포넌트\n│   │   ├── Timer/           # 타이머 컴포넌트\n│   │   │   ├── Timer.tsx\n│   │   │   ├── Timer.module.css\n│   │   ├── HUD/             # HUD 컴포넌트\n│   │   │   ├── HUD.tsx\n│   │   │   ├── HUD.module.css\n│   │   ├── ...\n│   ├── utils/               # 유틸리티 함수\n│   │   ├── audio.ts         # 오디오 관련 유틸리티\n│   │   ├── timer.ts         # 타이머 관련 유틸리티\n│   │   ├── ...\n│   ├── services/            # 외부 서비스 연동 (Whisper WASM)\n│   │   ├── speechRecognition.ts\n│   ├── pages/               # 페이지 컴포넌트\n│   │   ├── Home.tsx\n│   ├── App.tsx              # 최상위 컴포넌트\n│   ├── main.tsx             # 진입점\n│   ├── types/               # 타입 정의\n│   │   ├── timer.ts\n│   ├── assets/              # 이미지, 사운드 등 정적 자산\n│   ├── styles/              # 전역 스타일\n│   │   ├── global.css\n├── public/              # 정적 파일 (Whisper WASM 모델)\n├── vite.config.ts       # Vite 설정 파일\n├── tsconfig.json        # TypeScript 설정 파일\n├── package.json         # 패키지 관리 파일\n├── README.md\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: Frontend는 Cloudflare Pages를 통해 제공되는 정적 자산을 로드하고, 필요에 따라 Cloudflare Workers API를 호출한다.\n- **Database Interaction**: 데이터 영속화는 MVP에 포함되지 않으므로 데이터베이스는 사용하지 않는다.\n- **External Service Integration**: Whisper WASM은 브라우저 내에서 실행되므로 외부 서비스와의 직접적인 통신은 없다.\n- **Real-time Communication**: 실시간 타이머 업데이트는 React의 상태 관리 기능을 통해 처리한다.\n- **Data Synchronization**: 모든 데이터는 클라이언트 측에서 관리되며, 세션이 종료되면 데이터는 삭제된다.\n\n## 4. Performance & Optimization Strategy\n\n- **Whisper WASM 모델 최적화**: 모델 크기를 최소화하고, 필요한 부분만 로드하여 초기 로딩 시간을 단축한다.\n- **React 컴포넌트 최적화**: 불필요한 리렌더링을 방지하고, 메모이제이션을 활용하여 성능을 개선한다.\n- **코드 분할 (Code Splitting)**: Vite의 코드 분할 기능을 활용하여 초기 로딩에 필요한 코드만 로드하고, 나머지는 필요할 때 로드한다.\n- **CDN 활용**: Cloudflare Pages의 CDN을 활용하여 정적 자산을 빠르게 전송한다.\n\n## 5. Implementation Roadmap & Milestones\n### Phase 1: Foundation (MVP Implementation)\n- **Core Infrastructure**: Vite 프로젝트 설정, React 컴포넌트 구조 설계, TailwindCSS 스타일링 설정\n- **Essential Features**: 한국어 음성 명령 감지, 라인별 5분 타이머 시작, 라인별 실시간 타이머 UI, 타이머 종료 1분 전 음성 알림 + UI 강조, 수동 클릭 또는 핫키(F1~F5)로 타이머 시작·리셋, 게임 화면 위 작은 HUD(오버레이) 표시\n- **Basic Security**: 브라우저 마이크 권한 요청 및 보안 가이드 제공\n- **Development Setup**: 개발 환경 설정, 코드 저장소 (GitHub) 설정, CI/CD 파이프라인 (Cloudflare Pages) 설정\n- **Timeline**: 4주\n\n### Phase 2: Feature Enhancement\n- **Advanced Features**: 다국어(영어) 지원, 라인별 알림 음성/볼륨 커스터마이즈, 타이머 기록 공유·저장 기능, 모바일 웹 지원\n- **Performance Optimization**: Whisper WASM 모델 최적화, React 컴포넌트 최적화, 코드 분할, CDN 활용\n- **Enhanced Security**: 추가적인 보안 검토 및 취약점 분석\n- **Monitoring Implementation**: Google Analytics 또는 유사한 도구를 사용하여 사용자 행동 분석 및 성능 모니터링\n- **Timeline**: 4주\n\n## 6. Risk Assessment & Mitigation Strategies\n### Technical Risk Analysis\n- **Technology Risks**: Whisper WASM의 모델 크기로 인한 초기 로딩 지연, 브라우저별 마이크 권한 문제\n    - **Mitigation Strategies**: Web Speech API fallback 구현, 브라우저별 마이크 권한 가이드 제공\n- **Performance Risks**: HUD CPU 점유율 증가\n    - **Mitigation Strategies**: React 컴포넌트 최적화, 불필요한 리렌더링 방지\n- **Security Risks**: 악성 코드 삽입 및 XSS 공격 가능성\n    - **Mitigation Strategies**: 코드 검토, 입력 값 검증, Content Security Policy (CSP) 설정\n- **Integration Risks**: Web Speech API fallback 시 음성 인식 성능 저하\n    - **Mitigation Strategies**: Web Speech API 설정 조정 및 사용자 가이드 제공\n\n### Project Delivery Risks\n- **Timeline Risks**: 개발 일정 지연\n    - **Contingency Plans**: 기능 우선순위 조정, 추가 개발 인력 투입\n- **Resource Risks**: 핵심 개발자 이탈\n    - **Contingency Plans**: 코드 리뷰 및 지식 공유 강화, 대체 인력 확보\n- **Quality Risks**: 버그 발생 및 사용자 불만 증가\n    - **Contingency Plans**: 충분한 테스트 및 QA 수행, 사용자 피드백 수집 및 반영\n- **Deployment Risks**: 배포 과정에서 문제 발생\n    - **Contingency Plans**: 배포 자동화, 롤백 전략 마련\n",
      "writedAt": "2025-09-10T05:39:32.231Z"
    },
    {
      "type": "guideline",
      "content": "```markdown\n# No-pl Automatic Timer Code Guidelines\n\n## 1. Project Overview\n\nThis project is a web application designed to automatically manage lane-specific no-flash timers for League of Legends players using Korean voice commands. It leverages React, Vite, TailwindCSS, TypeScript, and Whisper WASM for real-time UI updates and voice recognition. Key architectural decisions include a component-based UI, local voice processing, and a domain-driven folder structure.\n\n## 2. Core Principles\n\n- **Maintainability:** Code should be easily understood, modified, and extended by any team member.\n- **Performance:** The application should provide a responsive and efficient user experience.\n- **Testability:** Code should be written in a way that facilitates unit and integration testing.\n- **Readability:** Code should be clear, concise, and well-documented.\n- **Consistency:** Adhere to established coding conventions and patterns throughout the project.\n\n## 3. Language-Specific Guidelines\n\n### TypeScript\n\n#### File Organization and Directory Structure\n\n- Follow the Domain-Driven Design principles as outlined in the TRD.\n- Group related components, types, and utilities within their respective domain directories.\n- Use descriptive file names (e.g., `Timer.tsx`, `timer.ts`, `Timer.module.css`).\n\n#### Import/Dependency Management\n\n- Use absolute imports for modules within the `src` directory (e.g., `import Timer from 'components/Timer/Timer';`).\n- Use relative imports for files within the same directory or closely related subdirectories.\n- Declare all dependencies in `package.json`.\n\n#### Error Handling Patterns\n\n- Use `try...catch` blocks for handling potential exceptions.\n- Implement custom error classes for specific error scenarios.\n- Log errors with sufficient context for debugging.\n\n```typescript\n// MUST: Example of try...catch block\ntry {\n  // Code that might throw an error\n  const result = await someAsyncFunction();\n  console.log('Result:', result);\n} catch (error: any) {\n  console.error('An error occurred:', error.message);\n  // Handle the error appropriately (e.g., display an error message to the user)\n}\n```\n\n### React\n\n#### Component Structure\n\n- Favor functional components with hooks.\n- Separate concerns into smaller, reusable components.\n- Use prop types for type checking and documentation.\n- Use `React.memo` for performance optimization.\n\n#### State Management\n\n- Use React's built-in `useState` and `useContext` hooks for local component state and simple global state management.\n- Consider a state management library (e.g., Zustand, Recoil) only if the application grows significantly in complexity. Avoid Redux unless absolutely necessary.\n\n#### Styling\n\n- Use CSS Modules for component-specific styling.\n- Follow the BEM (Block, Element, Modifier) naming convention.\n- Leverage TailwindCSS utility classes for rapid styling.\n\n```typescript\n// MUST: Example of a functional component with hooks\nimport React, { useState, useEffect } from 'react';\nimport styles from './Timer.module.css';\n\ninterface TimerProps {\n  initialTime: number;\n}\n\nconst Timer: React.FC<TimerProps> = ({ initialTime }) => {\n  const [time, setTime] = useState(initialTime);\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      setTime((prevTime) => prevTime - 1);\n    }, 1000);\n\n    return () => clearInterval(intervalId);\n  }, []);\n\n  return <div className={styles.timer}>{time}</div>;\n};\n\nexport default Timer;\n```\n\n### Whisper WASM\n\n#### Integration\n\n- Create a service module to encapsulate the Whisper WASM interaction.\n- Handle potential errors during initialization and recognition.\n- Optimize model loading for performance.\n\n#### Fallback\n\n- Implement a fallback to the Web Speech API in case Whisper WASM fails to load or initialize.\n- Provide clear instructions to the user if microphone access is denied.\n\n## 4. Code Style Rules\n\n### MUST Follow:\n\n- **Use TypeScript**: All code MUST be written in TypeScript to ensure type safety and maintainability. Rationale: TypeScript provides static typing, which helps catch errors early and improves code readability.\n- **Linting and Formatting**: Use ESLint and Prettier to enforce consistent code style. Rationale: Consistent code style improves readability and reduces cognitive load.\n- **Meaningful Names**: Use descriptive and meaningful names for variables, functions, and components. Rationale: Clear names make the code easier to understand and maintain.\n- **Comments**: Write clear and concise comments to explain complex logic or non-obvious behavior. Rationale: Comments help other developers (and your future self) understand the code's purpose and functionality.\n- **Small Functions**: Functions MUST be short and focused, ideally performing a single, well-defined task. Rationale: Smaller functions are easier to understand, test, and reuse.\n- **Error Handling**: Implement proper error handling using `try...catch` blocks and custom error classes. Rationale: Robust error handling prevents unexpected crashes and provides valuable debugging information.\n- **Avoid `any` type**: Minimize the usage of `any` type in TypeScript. Rationale: Using `any` defeats the purpose of TypeScript's type system.\n- **Code Reviews**: All code MUST be reviewed by at least one other team member before being merged into the main branch. Rationale: Code reviews help identify potential issues and ensure code quality.\n\n### MUST NOT Do:\n\n- **Magic Numbers**: Avoid using hardcoded numbers directly in the code. Use named constants instead. Rationale: Named constants improve readability and make it easier to change values in the future.\n- **Nested Callbacks**: Avoid deeply nested callbacks (callback hell). Use Promises or async/await for asynchronous operations. Rationale: Nested callbacks make the code difficult to read and maintain.\n- **Global Variables**: Avoid using global variables. Use dependency injection or state management solutions instead. Rationale: Global variables can lead to naming conflicts and make the code harder to reason about.\n- **Console Logs in Production**: Remove or disable `console.log` statements before deploying to production. Rationale: Console logs can expose sensitive information and impact performance.\n- **Ignoring Errors**: NEVER ignore errors. Always handle them appropriately, either by logging them, displaying an error message to the user, or retrying the operation. Rationale: Ignoring errors can lead to unexpected behavior and make it difficult to debug problems.\n- **Complex State Management**: Don't introduce complex state management patterns (e.g., Redux) prematurely. Start with React's built-in state management and only introduce more complex solutions if necessary. Rationale: Over-engineering can add unnecessary complexity and make the code harder to understand.\n- **Huge Components**: Avoid creating massive components with hundreds of lines of code. Break down complex components into smaller, reusable sub-components. Rationale: Smaller components are easier to understand, test, and maintain.\n\n## 5. Architecture Patterns\n\n### Component/Module Structure Guidelines\n\n- **Domain-Driven Design**: Organize code based on the business domain (e.g., `components/Timer`, `services/speechRecognition`).\n- **Layered Architecture**: Separate UI components, business logic, and data access layers.\n- **Reusable Components**: Design components to be reusable across different parts of the application.\n- **Single Responsibility Principle**: Each component or module should have a single, well-defined responsibility.\n\n### Data Flow Patterns\n\n- **Unidirectional Data Flow**: Data flows from parent components to child components via props, and changes are propagated back up via callbacks.\n- **State Management**: Use React's `useState` and `useContext` for local component state and simple global state. Consider Zustand for more complex state management needs.\n- **API Calls**: Encapsulate API calls in service modules.\n\n### State Management Conventions\n\n- **Local State**: Use `useState` for component-specific state.\n- **Context API**: Use `useContext` for simple global state that doesn't require complex updates.\n- **Zustand (Optional)**: Use Zustand for more complex global state management.\n\n### API Design Standards\n\n- **RESTful APIs**: Follow RESTful principles when designing APIs.\n- **JSON Format**: Use JSON for request and response bodies.\n- **Error Handling**: Return appropriate HTTP status codes and error messages.\n\n```typescript\n// MUST: Example of a service module for API calls\nimport axios from 'axios';\n\nconst API_BASE_URL = '/api'; // Or Cloudflare Worker URL\n\nexport const fetchData = async (endpoint: string) => {\n  try {\n    const response = await axios.get(`${API_BASE_URL}/${endpoint}`);\n    return response.data;\n  } catch (error: any) {\n    console.error('Error fetching data:', error.message);\n    throw error; // Re-throw the error for handling in the component\n  }\n};\n```\n```typescript\n// MUST NOT: Example of placing API logic directly in a component\nimport React, { useState, useEffect } from 'react';\nimport axios from 'axios';\n\nconst MyComponent = () => {\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n    // AVOID: Directly calling API in component\n    axios.get('/api/data')\n      .then(response => setData(response.data))\n      .catch(error => console.error(error));\n  }, []);\n\n  return (\n    <div>{/* ... */}</div>\n  );\n};\n\nexport default MyComponent;\n\n// Explanation: This approach tightly couples the component with the API, making it harder to test and reuse.  Move the API call to a dedicated service.\n```\n",
      "writedAt": "2025-09-10T05:39:32.231Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-09-10T05:39:32.231Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-09-10T05:39:32.231Z"
    }
  ]
}